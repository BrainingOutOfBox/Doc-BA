\section{Anleitung für Ideen-Erweiterungen}
\label{sec:Ideen_Erweiterung}

\subsection{Zweck dieses Dokuments}
Dieses Dokument stellt eine Anleitung für eine allfällige Erweiterung der vorhandenen Ideen-Typen dar. Ziel dieses Dokumentes ist es demzufolge, Hilfestellungen in solch einem Fall zu bieten. 

\subsection{Szenario}
Um diese Anleitung etwas einfacher und konkreter zu gestallten, gehen wir von einem bestimmten Szenario aus. Das Szenario sieht vor, dass man sich dazu entschieden hat die Applikation um den Ideen-Typ 'QualityIdea' zu erweitern.

Alle nachfolgenden Anpassungen beziehen sich daher auf dieses Szenario. Andere Ideen-Typen sind aber analog zu integrieren.

\subsection{Anpassungen am Backend}
\begin{labeling}{Zweiter Schritt:}
	\item [Erster Schritt:] Der erste Schritt im Backend besteht darin die entsprechenden Business-Objekte und Data-Transfer-Objekte mit all deren Attributen und Methoden anzulegen. Wichtig hierbei ist es, dass die neu erstellten Klassen von \texttt{Idea} bzw. \texttt{IdeaDTO} erben.
	\item [Zweiter Schritt:] Ist dies geschafft, muss dem JSON-Serialisierer noch beigebracht werden, dass ein weiterer Subtyp hinzugefügt wurde. Hierzu muss in der \texttt{IdeaDTO}-Klasse ein weiterer JsonSubTyp hinzugefügt werden (Zeile 5).
	
\begin{lstlisting}[caption={Weiterer Ideen-Typ hinzufügen in der IdeaDTO-Klasse}, label=addIdeaType]
@JsonTypeInfo(...)
@JsonSubTypes({
    @JsonSubTypes.Type(value = NoteIdeaDTO.class, name = "noteIdea"),
    ...,
    @JsonSubTypes.Type(value = QualityIdeaDTO.class, name = "qualityIdea")
        
})
\end{lstlisting}

	\item [Dritter Schritt:] In einem letzten Schritt muss nur noch die \texttt{ModelsMapper}-Klasse etwas angepasst werden (Zeile 4/6-9 bzw. 14/16-19). 

\begin{lstlisting}[caption={Weiterer Ideen-Typ hinzufügen in der ModelsMapper-Klasse}]
/* FROM BO TO DTO */
modelMapper.createTypeMap(Idea.class, IdeaDTO.class)
    ...
    .include(QualityIdea.class, IdeaDTO.class);

modelMapper.typeMap(QualityIdea.class, IdeaDTO.class).setProvider(request -> {
    QualityIdea idea = (QualityIdea)request.getSource();
    return new QualityIdeaDTO(idea.getDescription(), ...);
});

/* FROM DTO TO BO */
modelMapper.createTypeMap(IdeaDTO.class, Idea.class)
    ...
    .include(QualityIdeaDTO.class, Idea.class);

modelMapper.typeMap(QualityIdeaDTO.class, Idea.class).setProvider(request -> {
    QualityIdeaDTO idea = (QualityIdeaDTO)request.getSource();
    return new QualityIdea(idea.getDescription(), ...);
});
\end{lstlisting}
\end{labeling}

Diese drei Schritte sollten ausreichen, damit das Backend auch mit einer QualityIdea interagieren kann. 

\subsection{Anpassungen am Frontend}
%TODO Anpassungen für Frontend schreiben

\subsection{Erfüllung der nicht-funktionalen Anforderungen} 
Wie im Kapitel \ref{subsub:nfr} beschrieben, war es unter anderem unser Ziel, unsere Applikation in Bezug auf Erweiterung und Modularität zu verbessern. Wir wollen daher hier nochmals speziell Bezug nehmen auf diese Ziele und beurteilen wie gut diese umgesetzt wurden.

Wir sind der Meinung, dass sich in Punkto Erweiterbarkeit noch viele weitere Ideenarten für eine mögliche Integrierung eignen würden. Im Kapitel \ref{subsub:Ausblick} haben wir dafür drei konkrete Ideenarten aufgeschrieben. Zudem gibt es Ideenarten, wie z.B. die PictureIdea oder VideoIdea, welche wir zwar zu Beginn dieser Arbeit definiert hatten aber mangels Zeit nicht umsetzen konnten. Sicherlich gibt es noch viele weitere Ideenarten, welche sich in die bestehende Applikation integrieren liessen.

Das Ziel der Erweiterbarkeit sehen wir daher als übertroffen an.

Dank der vorliegenden Anleitung sind wir zudem der Ansicht, dass sich die Applikation innert wenigen Tagen um eine neue Ideenart erweitern liesse. In Zahlen ausgedrückt, sollte sich solch ein Vorhaben schätzungsweise innert 2 Tagen realisieren lassen. 

Das Ziel der Modularität wäre somit optimal erreicht.

\begin{center}
    \begin{tabular}{ | p{6cm} | p{2.5cm} | p{2.5cm} | p{2.5cm} |}
    	\hline
    Kriterium & Minimum & Optimal & Übertroffen \\ 
    	\hline
    \textbf{Erweiterbarkeit} \newline Die Anzahl an neuen Ideenarten, welche mit der bestehenden Architektur als umsetzbar gelten, wird als ... angesehen & zu wenig (0-1) & ausreichend (1-5) & unbegrenzt ($>$5)\\
    	\hline
    \textbf{Modularität} \newline Die App ist innert ... Tagen um eine neue Ideenart erweitert & 5 Tage & 2 Tage & weniger als 1 Tag \\
    	\hline
    \end{tabular}
\end{center}

\subsection{Exkurs: Andere Datenbank verwenden}
Der Vollständigkeitshalber soll in diesem Kapitel auch erläutert werden, wie die momentan verwendete MongoDB Datenbank ausgewechselt werden kann, sollte dies notwendig sein.

Dies kann in zwei einfachen Schritten erreicht werden.

\begin{labeling}{Zweiter Schritt:}
	\item [Erster Schritt:] Zunächst muss jedes der fünf Datenbank-Interfaces für die neue Datenbankanbindung in einer entsprechenden Klasse (z.B. MySQL\-Finding\-Service-Klasse) implementiert werden. 
	\item [Zweiter Schritt:] In einem zweiten Schritt muss im Interface nur noch mitgeteilt werden, von welcher Klasse dieses implementiert wird.

\begin{lstlisting}[caption={Andere Datenbank verwenden}, label=changeDatabase]
@ImplementedBy(MySQLFindingService.class)
public interface DBFindingInterface {...}
\end{lstlisting}
\end{labeling}
