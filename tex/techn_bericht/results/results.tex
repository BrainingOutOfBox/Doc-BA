\subsection{Ergebnisse}
Das Kapitel der Ergebnisse befasst sich mit der konkreten Umsetzung der gesamten Applikation und dokumentiert die grundlegenden Ergebnisse oder Resultate, welche aus dieser Arbeit hervorgegangen sind. 

Auch hier soll nochmals erwähnt sein, dass diese Arbeit auf der Studienarbeit \cite{methode635-sa} aufbaut und grundlegende Informationen dort nachzulesen sind. 

In diesem Kapitel gehen wir zunächst auf die Änderungen während der Refactoring-Phase ein und schildern was dies für die Wartung und Erweiterung des Codes bedeutet. 

Anschliessend sind weitere Features dokumentiert, welche im Verlauf dieser Arbeit an der Applikation durchgeführt wurden.

Das Kapitel wird durch eine Gegenüberstellung der erreichten und geplanten Arbeit abgeschlossen.

Zur besseren Übersicht wurde der Code vereinzelt gekürzt. Dies ist durch 3 Punkte (...) gekennzeichnet.

\subsubsection{Refactoring zu Beginn der Arbeit}
Wie aus dem Projektplan (siehe Abbildung \ref{fig:projekt-plan}) zu entnehmen ist, haben wir uns zu Beginn unserer Arbeit dazu entschieden, zwei Sprints für das Refactoring unsere Applikation zu nutzen. Die Entscheidung überhaupt ein Refactoring durchzuführen entstand aus der Tatsache, dass wir schon gegen Ende der Studienarbeit gemerkt hatten, dass bei einer allfälligen Weiterführung der Arbeit ein Refactoring von grossem Wert sein wird. Auch haben wir diesbezüglich schon während der Studienarbeit einzelne Vorschläge für ein Refactoring beschrieben.


Das Ziel der Refactoring-Phase war es daher, den Code welcher aus der Studienarbeit hervorgegangen ist, zu prüfen und zu verbessern. Dies sollte uns helfen, die Erweiterbarkeit für zukünftig geplante Features zu gewähren. Für die Überprüfung konnte Silvan Gehrig gewonnen werden. Seine Rückmeldungen, welche im Anhang \ref{sec:code-review} nachgelesen werden können, wurden wie nachfolgend beschrieben umgesetzt.

Auch konnten wir die in der Studienarbeit beschriebenen Vorschläge erfolgreich in der App umsetzen.
 
\paragraph*{Refactoring Backend}~\\
Dieser Abschnitt ist so aufgebaut, dass anhand von zwei Beispielen aufgezeigt werden soll, wie der Code im Backend vor und nach dem Refactoring ausgesehen hat. Auch wird am Ende des Abschnitts kurz erwähnt, was dies für Verbesserungen zur Folge hatte.

Das nachfolgende Listing \ref{participantErstellenVorRef} zeigt einen Ausschnitt aus der \texttt{Participant\-Controller\-.java} Klasse wie es vor dem Refactoring war. Das Listing \ref{participantErstellenNachRef} zeigt dieselbe Methode nach dem Refactoring.

\lstset{language=JAVA, showstringspaces=false, frame=single, captionpos=b, label=createParticipant, breaklines=true, numbers=left}
\begin{lstlisting}[caption={Participant erstellen vor Refactoring}, label=participantErstellenVorRef]
public Result createParticipant(){

    JsonNode body = request().body().asJson();

    if (body == null ) {
        return forbidden(Json.toJson(new ErrorMessage("Error", "json body is null")));
    } else if(  body.hasNonNull("username") &&
            	body.hasNonNull("password") &&
            	body.hasNonNull("firstname") &&
            	body.hasNonNull("lastname")) {

    Participant participant = new Participant(body.get("username").asText(), body.get("password").asText(), body.get("firstname").asText(), body.get("lastname").asText());

    participantCollection.insertOne(participant, new SingleResultCallback<Void>() {
        @Override
        public void onResult(Void result, Throwable t) {
            Logger.info("Inserted Participant!");
        }
    });

    return ok(Json.toJson(new SuccessMessage("Success", "Participant successfully inserted")));
    }

    return forbidden(Json.toJson(new ErrorMessage("Error", "json body not as expected")));
}
\end{lstlisting}

\begin{lstlisting}[caption={Participant erstellen nach Refactoring}, label=participantErstellenNachRef]
@BodyParser.Of(ParticipantDTOBodyParser.class)
public Result createParticipant() {
    ParticipantDTO participantDTO = request().body().as(ParticipantDTO.class);
    Participant participant = modelsMapper.toParticipant(participantDTO);

    try {
        if (service.insertParticipant(participant)){
            return ok(Json.toJson(new SuccessMessage("Success", "Participant successfully inserted")));
        } else {
            Logger.info("Username already exists");
            return badRequest(Json.toJson(new ErrorMessage("Error", "Username already exists")));
        }
    } catch (ExecutionException | InterruptedException e) {
        return internalServerError(Json.toJson(new ErrorMessage("Error", e.getMessage())));
    }
}
\end{lstlisting}

Das Erstellen des Participants wurde komplett in den \texttt{Participant\-DTO\-Body\-Parser\-.class} ausgelagert. Dieser erstellt nun aus dem angelieferten JSON ein Data-Transfer-Object \cite{DTO}, welches in einem nächsten Schritt zu einem Business Object aufgelöst wird (Zeile 5).

Jegliche Überprüfungen aus Listing \ref{participantErstellenVorRef} (Zeilen 5 und 7-10) konnten so zentral in den BodyParser ausgelagert werden.

Bei den nachfolgenden Listings \ref{putBrainsheetVorRef} und \ref{putBrainsheetNachRef}, welche einen Ausschnitt aus dem \texttt{Brain\-storming\-Finding\-Controller\-.java} zeigen, ist der Unterschied noch stärker zu sehen. So konnte zum Beispiel die \texttt{putBraisheet} Methode von zirka 40 Zeilen auf 15 Zeilen gekürzt werden. 

\begin{lstlisting}[caption={PutBrainsheet vor Refactoring}, label=putBrainsheetVorRef]
public Result putBrainsheet(String findingIdentifier) throws ExecutionException, InterruptedException {

JsonNode body = request().body().asJson();
JsonNode brainwaves = body.findPath("brainwaves");
JsonNode nrOfSheet = body.findPath("nrOfSheet");

if (body == null ) {
    return forbidden(Json.toJson(new ErrorMessage("Error", "json body is null")));
} else if(  !brainwaves.isNull() &&
            !nrOfSheet.isNull()){

	BrainstormingFinding finding = getBrainstormingFinding(findingIdentifier);

    if (finding == null){
        return internalServerError(Json.toJson(new ErrorMessage("Error", "No brainstormingFinding found")));
    }

    Brainsheet oldBrainsheet = finding.getBrainsheets().get(nrOfSheet.asInt());
    Brainsheet newBrainsheet = createBrainsheet(body);


    findingCollection.updateOne(eq("identifier", findingIdentifier),pullByFilter(Filters.eq("brainsheets", oldBrainsheet)), new SingleResultCallback<UpdateResult>() {
        @Override
        public void onResult(final UpdateResult result, final Throwable t) {
            Logger.info(result.getModifiedCount() + " Brainsheet successfully deleted");
        }
    });

    findingCollection.updateOne(eq("identifier", findingIdentifier),combine(pushEach("brainsheets", Arrays.asList(newBrainsheet), new PushOptions().position(newBrainsheet.getNrOfSheet())), inc("deliveredBrainsheetsInCurrentRound", 1)), new SingleResultCallback<UpdateResult>() {
        @Override
        public void onResult(final UpdateResult result, final Throwable t) {
            Logger.info(result.getModifiedCount() + " Brainsheet successfully inserted");
        }
    });

    return ok(Json.toJson(new SuccessMessage("Success", "Brainsheet successfully updated")));
}

return forbidden(Json.toJson(new ErrorMessage("Error", "json body not as expected")));
}
\end{lstlisting}


\begin{lstlisting}[caption={PutBrainsheet nach Refactoring}, label=putBrainsheetNachRef]
@BodyParser.Of(BrainsheetDTOBodyParser.class)
public Result putBrainsheet(String findingIdentifier){
    BrainsheetDTO brainsheetDTO = request().body().as(BrainsheetDTO.class);
    Brainsheet newBrainsheet = modelsMapper.toBrainsheet(brainsheetDTO);

    try {

        if (service.exchangeBrainsheet(findingIdentifier, newBrainsheet)) {
            return ok(Json.toJson(new SuccessMessage("Success", "Brainsheet successfully updated")));
        } else {
            return badRequest(Json.toJson(new ErrorMessage("Error", "No Brainsheet updated")));
        }

    } catch (ExecutionException | InterruptedException e) {
        return internalServerError(Json.toJson(new ErrorMessage("Error", e.getMessage())));
    }
}
\end{lstlisting}

Die gesamte Logik für den Austausch der Brainsheets wurde in die \texttt{FindingService\-.java} Klasse ausgelagert.

\begin{lstlisting}[caption={Exchange Brainsheet im Business Layer}, label=exchangeBrainsheetBusinessLayer]
public boolean exchangeBrainsheet(String findingIdentifier, Brainsheet newBrainsheet) {
BrainstormingFinding finding = service.getFinding(findingIdentifier).get();

if (finding == null){
    return false;
} else {
    if (newBrainsheet.getNrOfSheet() < finding.getBrainsheets().size()) {
        Brainsheet oldBrainsheet = finding.getBrainsheets().get(newBrainsheet.getNrOfSheet());
        service.exchangeBrainsheet(finding, oldBrainsheet, newBrainsheet);
        return true;
    }
    return false;
}

}
\end{lstlisting}

Auch wurde die Implementation für das Einfügen in die Datenbank in eine separate Klasse (\texttt{MongoDBFindingservice.java}) ausgelagert, um eine bessere Übersicht und ein besseres Layering zu gewähren.

\begin{lstlisting}[caption={Exchange Brainsheet im Data Access Layer}, label=exchangeBrainsheetDAL]
public void exchangeBrainsheet(BrainstormingFinding finding, Brainsheet oldBrainsheet, Brainsheet newBrainsheet){
    
    //delete old Brainsheet
    findingCollection.updateOne(eq("identifier", finding.getIdentifier()),pullByFilter(Filters.eq("brainsheets", oldBrainsheet)), (result, t) -> Logger.info(result.getModifiedCount() + " old Brainsheet successfully deleted"));
    
    //insert new Brainsheet at the same place
    findingCollection.updateOne(eq("identifier", finding.getIdentifier()),combine(pushEach("brainsheets", Arrays.asList(newBrainsheet), new PushOptions().position(newBrainsheet.getNrOfSheet())), inc("deliveredBrainsheetsInCurrentRound", 1)), (result, t) -> Logger.info(result.getModifiedCount() + " new Brainsheet successfully inserted"));
}
\end{lstlisting}
Diese zwei Beispiele stellen noch lange nicht alle überarbeiteten Codestellen dar, geben aber eine gute Übersicht, wie der gesamte Code vereinfacht werden konnte.

\paragraph*{Fazit}
Gerade das Beispiel vom Austausch der Brainsheets (Listing \ref{putBrainsheetVorRef}) verdeutlicht, dass das Layering stark verbessert wurde. Vieles was vorher in einer Klasse war, konnte in verschiedene Klassen ausgelagert werden. Damit konnte die Übersicht und Komplexität deutlich verbessert werden.

Auch wurden im gesamten Backend Data-Transfer-Obekte (DTO) \cite{DTO} eingefügt. Dies ermöglicht eine stärkere Trennung von relevanten Informationen für Business-Objekte (BO) und relevanten Informationen für Data-Transfer-Obekte. Dies war vor allem im späteren Verlauf der Arbeit von grossem Wert.

Mit Hilfe der BodyParser-Klassen konnte die komplette Überprüfung und Deserialisierung der angelieferten JSON-Daten zentral geregelt werden. Somit ist immer sichergestellt, dass das DTO korrekt (alle erwarteten Informationen sind vorhanden und das Format stimmt) erstellt wird. 

\paragraph*{Refactoring Frontend}

\subsubsection{Implementation Skizzen Feature}
\paragraph*{Implementation Backend}

\paragraph*{Implementation Frontend}

\subsubsection{Implementation Pattern Feature}
\paragraph*{Implementation Backend}

\paragraph*{Implementation Frontend}

\subsubsection{Implementation Export Feature}
\paragraph*{Implementation Backend}

\paragraph*{Implementation Frontend}

\subsubsection{Verwendete Bibliotheken im Backend}
Tabelle \ref{tab:verwendete-libraries-play} zeigt die Bibliotheken auf, die im Backend verwendet werden. 
\begin{table}[h]
	\centering
	\begin{tabular}{| l | l | c | l |}
		\hline
		\textbf{Bibliothek} & \textbf{Version} & \textbf{Repository} & \textbf{Lizenz}\\
		\hline
		swagger-play2 & 1.6.0 & \href{https://mvnrepository.com/artifact/io.swagger/swagger-play2_2.12/1.6.0}{mvnrepository.com} & Apache 2.0 \\
		java-jwt & 3.2.0 & \href{https://mvnrepository.com/artifact/com.auth0/java-jwt/3.2.0}{mvnrepository.com} & MIT \\
		mongodb-driver-async & 3.8.0 & \href{https://mvnrepository.com/artifact/org.mongodb/mongodb-driver-async/3.8.0}{mvnrepository.com} & MIT \\
		modelmapper & 2.3.2 & \href{https://mvnrepository.com/artifact/org.modelmapper/modelmapper/2.3.2}{mvnrepository.com} & Apache 2.0 \\
		markdowngenerator & 1.3.1.1 & \href{https://mvnrepository.com/artifact/net.steppschuh.markdowngenerator/markdowngenerator}{mvnrepository.com} & Apache 2.0 \\
		\hline
	\end{tabular}
	\caption[Story-Points]{Verwendete Bibliotheken Backend}
	\label{tab:verwendete-libraries-play}
\end{table}

\subsubsection{Verwendete Bibliotheken im Frontend}
In Tabelle \ref{tab:verwendete-libraries-frontend} sind die verwendeten Libraries und Frameworks des Frontends aufgelistet.
\begin{table}[!h]
	\centering
	\begin{tabular}{| l | l | c | l |}
		\hline
		\textbf{Bibliothek} & \textbf{Version} & \textbf{Repository} & \textbf{Lizenz}\\
		\hline
		CarouselView.FormsPlugin & 5.2.0 & \href{https://github.com/alexrainman/CarouselView}{github.com} & MIT \\
		Microsoft.AppCenter & 1.10.0 & \href{https://visualstudio.microsoft.com/app-center/}{AppCenter} & MIT \\
		NUnit & 3.11.0 & \href{http://nunit.org}{nunit.org} & MIT\\
		NUnit3TestAdapter & 3.11.2 & \href{https://github.com/nunit/docs/wiki/Visual-Studio-Test-Adapter}{github.com} & MIT\\
		Prism.Forms & 7.0.0.396 & \href{https://github.com/PrismLibrary/Prism}{github.com} & MIT \\
		Xamarin.Forms & 3.3.0.912540 & \href{https://docs.microsoft.com/en-us/xamarin/xamarin-forms/}{Microsoft Docs} & MIT \\
		XamlStyler.Console & 3.0.0 & 
		\href{https://github.com/Xavalon/XamlStyler}{github.com} & Apache 2.0\\
		ZXing.Net.Mobile & 2.4.1 & \href{http://github.com/Redth/ZXing.Net.Mobile}{github.com} & Apache 2.0\\
		ZXing.Net.Mobile.Forms & 2.4.1 &
		\href{http://github.com/Redth/ZXing.Net.Mobile}{github.com} & Apache 2.0\\
		\hline
	\end{tabular}
	\caption{Direkt verwendete Bibliotheken Frontend}
	\label{tab:verwendete-libraries-frontend}
\end{table}


\subsubsection{Vergleich Soll/Ist}
%TODO